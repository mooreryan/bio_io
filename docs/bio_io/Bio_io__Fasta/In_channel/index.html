<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>In_channel (bio_io.Bio_io__Fasta.In_channel)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">bio_io</a> &#x00BB; <a href="../index.html">Bio_io__Fasta</a> &#x00BB; In_channel</nav><h1>Module <code>Bio_io__Fasta.In_channel</code></h1><p><code>In_channel</code> for FASTA records. For more general info, see the <code>Record_in_channel</code> module mli file.</p><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><h3 id="return-all-records-in-a-list"><a href="#return-all-records-in-a-list" class="anchor"></a>Return all records in a list</h3><p>Simplest way. May raise exceptions.</p><pre><code class="ml">let records = Fasta.In_channel.with_file_records_exn fname</code></pre><p>A bit more involved, but you won't get exceptions. Instead, you have to handle the <code>Or_error.t</code>.</p><pre><code class="ml">let records =
  match Fasta.In_channel.with_file_records name with
  | Error err -&gt;
      eprintf &quot;Problem reading records: %s\n&quot; (Error.to_string_hum err);
      exit 1
  | Ok records -&gt; records</code></pre><h3 id="iterating-over-records"><a href="#iterating-over-records" class="anchor"></a>Iterating over records</h3><p>Use the <code>iter</code> functions when you need to go over each record and perform some side-effects with them.</p><p>Print sequence IDs and sequence lengths</p><pre><code class="ml">let () =
  Fasta.In_channel.with_file_iter_records_exn &quot;sequences.fasta&quot;
    ~f:(fun record -&gt;
      let open Fasta.Record in
      printf &quot;%s =&gt; %d\n&quot; (id record) (seq_length record))</code></pre><p>Print sequence index, IDs, and sequence lengths.</p><p>This is like the last example except that we also want to print the index. The first record is 0, the 2nd is 1, etc.</p><pre><code class="ml">let () =
  Fasta.In_channel.with_file_iteri_records_exn &quot;sequences.fasta&quot;
    ~f:(fun index record -&gt;
      let open Fasta.Record in
      printf &quot;%d: %s =&gt; %d\n&quot; (index + 1) (id record)
        (seq_length record)</code></pre><h3 id="folding-over-records"><a href="#folding-over-records" class="anchor"></a>Folding over records</h3><p>If you need to reduce all the records down to a single value, use the <code>fold</code> functions.</p><p>Get total length of all sequences in the file.</p><p>Watch out as this may raise exceptions...see the <code>_exn</code> suffix.</p><pre><code class="ml">let total_length =
  Fasta.In_channel.with_file_fold_records_exn &quot;sequences.fasta&quot; ~init:0
    ~f:(fun length record -&gt; length + Fasta.Record.seq_length record)</code></pre><p>Same thing, but this won't raise exceptions. You do have to handle <code>Or_error.t</code> to get the final value. Note that within the fold function, you get <code>Fasta.Record.t</code> and not <code>Fasta.Record.t Or_error.t</code>.</p><pre><code class="ml">let total_length =
  match
    Fasta.In_channel.with_file_fold_records name ~init:0
      ~f:(fun length record -&gt; length + Fasta.Record.seq_length record)
  with
  | Error err -&gt;
      eprintf &quot;Problem reading records: %s\n&quot; (Error.to_string_hum err);
      exit 1
  | Ok total_length -&gt; total_length</code></pre><h3 id="pipelines"><a href="#pipelines" class="anchor"></a>Pipelines with records</h3><p>Sometimes you have a &quot;pipeline&quot; of computations that you need to do one after the other on records. In that case, you could the <code>sequence</code> functions. Here's a silly example.</p><pre><code class="ml">let () =
  Fasta.In_channel.with_file_exn name ~f:(fun chan -&gt;
      Fasta.In_channel.record_sequence_exn chan
      (* Add sequence index to record description *)
      |&gt; Sequence.mapi ~f:(fun i record -&gt;
             let new_desc =
               match Fasta.Record.desc record with
               | None -&gt; Some (sprintf &quot;sequence %d&quot; i)
               | Some old_desc -&gt;
                   Some (sprintf &quot;%s -- sequence %d&quot; old_desc i)
             in
             Fasta.Record.with_desc new_desc record)
      (* Convert all sequence chars to lowercase *)
      |&gt; Sequence.map ~f:(fun record -&gt;
             let new_seq = String.lowercase (Fasta.Record.seq record) in
             Fasta.Record.with_seq new_seq record)
      (* Print sequences *)
      |&gt; Sequence.iter ~f:(fun record -&gt;
             print_endline @@ Fasta.Record.serialize record))</code></pre><p>One thing to watch out for though...if you get an exception half way through and you are running side-effecting code like we are here then part of your side effects will have occured and part of them will <i>not</i> have occured.</p><p>There are also <code>Or_error.t</code> flavors of the <code>sequence</code> functions. Just watch out because these you actually <i>do</i> have to deal with <code>Or_error.t</code> for each <code>Fasta.Record.t</code> in the sequence.</p><p>As an alternative, you could use the <code>record_sequence_exn</code> function, but wrap <i>that</i> in the <code>with_file</code> function. That way you don't have to deal with the <code>Or_error.t</code> inside your pipeline. Instead you deal with it at the end.</p><pre><code class="ml">let total_length =
  match
    Fasta.In_channel.with_file name ~f:(fun chan -&gt;
        Fasta.In_channel.record_sequence_exn chan
        (* Blow up pipeline on second sequence. *)
        |&gt; Sequence.mapi ~f:(fun i record -&gt;
               if i = 1 then assert false;
               record)
        |&gt; Sequence.fold ~init:0 ~f:(fun length record -&gt;
               length + String.length (Fasta.Record.seq record)))
  with
  | Error err -&gt;
      eprintf &quot;Problem in parsing pipeline: %s\n&quot;
        (Error.to_string_hum err);
      exit 1
  | Ok total_length -&gt; total_length</code></pre><p>As you can see, if that fasta file has more than one sequence it will hit the <code>assert false</code> and blow up.</p></header><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="../../Bio_io/Record_in_channel/index.html#module-type-S">Bio_io.Record_in_channel.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="../../Bio_io/Record_in_channel/module-type-S/index.html#type-record">record</a> := <a href="../Record/index.html#type-t">Record.t</a></code></span></summary><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dt class="spec type" id="type-record"><a href="#type-record" class="anchor"></a><code><span class="keyword">type</span> record</code></dt></dl><dl><dt class="spec value" id="val-stdin"><a href="#val-stdin" class="anchor"></a><code><span class="keyword">val</span> stdin : <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_exn file_name</code> opens an <code>t</code> on the standard input channel.</p></dd></dl><dl><dt class="spec value" id="val-create_exn"><a href="#val-create_exn" class="anchor"></a><code><span class="keyword">val</span> create_exn : Base.string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>create_exn file_name</code> opens an input channel on the file specified by <code>file_name</code>.</p></dd></dl><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : Base.string <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Base.Or_error.t</span></code></dt><dd><p><code>create file_name</code> opens an input channel on the file specified by <code>file_name</code>.</p></dd></dl><dl><dt class="spec value" id="val-close_exn"><a href="#val-close_exn" class="anchor"></a><code><span class="keyword">val</span> close_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.unit</code></dt><dd><p><code>close_exn t</code> Close the <code>t</code>. Raises if the call fails.</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Base.unit Base.Or_error.t</span></code></dt><dd><p><code>close t</code> is like <code>close_exnt t</code> except that it shouldn't raise.</p></dd></dl><dl><dt class="spec value" id="val-with_file_exn"><a href="#val-with_file_exn" class="anchor"></a><code><span class="keyword">val</span> with_file_exn : Base.string <span>&#45;&gt;</span> <span>f:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>with_file_exn file_name ~f</code> executes <code>~f</code> on the channel created from <code>file_name</code> and closes it afterwards.</p></dd></dl><dl><dt class="spec value" id="val-with_file"><a href="#val-with_file" class="anchor"></a><code><span class="keyword">val</span> with_file : Base.string <span>&#45;&gt;</span> <span>f:<span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.Or_error.t</span></code></dt><dd><p><code>with_file file_name ~f</code> is like <code>with_file_exn file_name ~f</code> except that it shouldn't raise.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.bool</code></dt><dd><p><code>equal t1 t2</code> compares <code>t1</code> and <code>t2</code> for equality.</p></dd></dl><dl><dt class="spec value" id="val-input_record_exn"><a href="#val-input_record_exn" class="anchor"></a><code><span class="keyword">val</span> input_record_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-record">record</a> Base.option</span></code></dt><dd><p><code>input_record_exn t</code> returns <code>Some record</code> if there is a <code>record</code> to return. If there are no more records, <code>None</code> is returned. <code>Exn</code> is raised on bad input.</p></dd></dl><dl><dt class="spec value" id="val-input_record"><a href="#val-input_record" class="anchor"></a><code><span class="keyword">val</span> input_record : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-record">record</a> Base.option</span> Base.Or_error.t</span></code></dt><dd><p><code>input_record t</code> is like <code>input_record_exn t</code> except that it should not raise exceptions.</p></dd></dl><section><header><h3 id="folding-over-records"><a href="#folding-over-records" class="anchor"></a>Folding over records</h3></header><dl><dt class="spec value" id="val-fold_records_exn"><a href="#val-fold_records_exn" class="anchor"></a><code><span class="keyword">val</span> fold_records_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold_records_exn t ~init ~f</code> reduces all records from a <code>t</code> down to a single value of type <code>'a</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_records"><a href="#val-fold_records" class="anchor"></a><code><span class="keyword">val</span> fold_records : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.Or_error.t</span></code></dt><dd><p><code>fold_records t ~init ~f</code> is like <code>fold_records_exn t ~init ~f</code> except that it should not raise exceptions. Rather than deal with exceptions inside the reducing function, you must deal with them at the end when handling the return value.</p></dd></dl><dl><dt class="spec value" id="val-foldi_records_exn"><a href="#val-foldi_records_exn" class="anchor"></a><code><span class="keyword">val</span> foldi_records_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(Base.int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p>Like <code>fold_records_exn t ~init ~f</code> except that <code>f</code> is provided the 0-based record index as its first argument. See <a href="index.html#val-fold_records_exn"><code>fold_records_exn</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-foldi_records"><a href="#val-foldi_records" class="anchor"></a><code><span class="keyword">val</span> foldi_records : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(Base.int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.Or_error.t</span></code></dt><dd><p>Like <code>foldi_records_exn t ~init ~f</code> except that it shouldn't raise. See <a href="index.html#val-foldi_records_exn"><code>foldi_records_exn</code></a>.</p></dd></dl><section><header><h4 id="folding-with-file-name"><a href="#folding-with-file-name" class="anchor"></a>Folding with file name</h4></header><dl><dt class="spec value" id="val-with_file_fold_records_exn"><a href="#val-with_file_fold_records_exn" class="anchor"></a><code><span class="keyword">val</span> with_file_fold_records_exn : Base.string <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>with_file_fold_records_exn file_name ~init ~f</code> is like <code>fold_records_exn t ~init ~f</code> except that it is passed a file name, and it manages <code>t</code> automatically. See <a href="index.html#val-with_file"><code>with_file</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-with_file_fold_records"><a href="#val-with_file_fold_records" class="anchor"></a><code><span class="keyword">val</span> with_file_fold_records : Base.string <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.Or_error.t</span></code></dt><dd><p><code>with_file_fold_records file_name ~init ~f</code> is like <code>fold_records t ~init ~f</code> except that it is passed a file name, and it manages <code>t</code> automatically. See <a href="index.html#val-with_file"><code>with_file</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-with_file_foldi_records_exn"><a href="#val-with_file_foldi_records_exn" class="anchor"></a><code><span class="keyword">val</span> with_file_foldi_records_exn : Base.string <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(Base.int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>with_file_foldi_records_exn file_name ~init ~f</code> is like <code>foldi_records_exn t ~init ~f</code> except that it is passed a file name, and it manages <code>t</code> automatically. See <a href="index.html#val-with_file"><code>with_file</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-with_file_foldi_records"><a href="#val-with_file_foldi_records" class="anchor"></a><code><span class="keyword">val</span> with_file_foldi_records : Base.string <span>&#45;&gt;</span> <span>init:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>f:<span>(Base.int <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.Or_error.t</span></code></dt><dd><p><code>with_file_foldi_records file_name ~init ~f</code> is like <code>fold'_records t ~init ~f</code> except that it is passed a file name, and it manages <code>t</code> automatically. See <a href="index.html#val-with_file"><code>with_file</code></a>.</p></dd></dl></section></section><section><header><h3 id="iterating-over-records"><a href="#iterating-over-records" class="anchor"></a>Iterating over records</h3><p>The <code>iter</code> functions are like the <code>fold</code> functions except they do not take an <code>init</code> value and the <code>f</code> function returns <code>unit</code> insead of some other value <code>'a</code>, and thus return <code>unit</code> rather than a value <code>'a</code>.</p><p>They are mainly called for side effects.</p></header><dl><dt class="spec value" id="val-iter_records_exn"><a href="#val-iter_records_exn" class="anchor"></a><code><span class="keyword">val</span> iter_records_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="index.html#type-record">record</a> <span>&#45;&gt;</span> Base.unit)</span></span> <span>&#45;&gt;</span> Base.unit</code></dt><dd><p><code>iter_records_exn t ~f</code> calls <code>f</code> on each <code>record</code> in <code>t</code>. As <code>f</code> returns <code>unit</code> this is generally used for side effects.</p></dd></dl><dl><dt class="spec value" id="val-iter_records"><a href="#val-iter_records" class="anchor"></a><code><span class="keyword">val</span> iter_records : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(<a href="index.html#type-record">record</a> <span>&#45;&gt;</span> Base.unit)</span></span> <span>&#45;&gt;</span> <span>Base.unit Base.Or_error.t</span></code></dt><dd><p><code>iter_records t ~f</code> is like <code>iter_records_exn t ~f</code> except that it shouldn't raise.</p></dd></dl><dl><dt class="spec value" id="val-iteri_records_exn"><a href="#val-iteri_records_exn" class="anchor"></a><code><span class="keyword">val</span> iteri_records_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(Base.int <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> Base.unit)</span></span> <span>&#45;&gt;</span> Base.unit</code></dt><dd><p><code>iteri_records_exn t ~f</code> is like <code>iteri_records_exn t ~f</code> except that <code>f</code> is passed in the 0-indexed record index as its first argument.</p></dd></dl><dl><dt class="spec value" id="val-iteri_records"><a href="#val-iteri_records" class="anchor"></a><code><span class="keyword">val</span> iteri_records : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>f:<span>(Base.int <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> Base.unit)</span></span> <span>&#45;&gt;</span> <span>Base.unit Base.Or_error.t</span></code></dt><dd><p><code>iteri_records t ~f</code> is like <code>iteri_records_exn t ~f</code> except that it shouldn't raise.</p></dd></dl><section><header><h4 id="iterating-with-file-name"><a href="#iterating-with-file-name" class="anchor"></a>Iterating with file name</h4></header><dl><dt class="spec value" id="val-with_file_iter_records_exn"><a href="#val-with_file_iter_records_exn" class="anchor"></a><code><span class="keyword">val</span> with_file_iter_records_exn : Base.string <span>&#45;&gt;</span> <span>f:<span>(<a href="index.html#type-record">record</a> <span>&#45;&gt;</span> Base.unit)</span></span> <span>&#45;&gt;</span> Base.unit</code></dt><dd><p><code>with_file_iter_records_exn file_name ~init ~f</code> is like <code>iter_records_exn t ~init ~f</code> except that it is passed a file name, and it manages <code>t</code> automatically. See <a href="index.html#val-with_file"><code>with_file</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-with_file_iter_records"><a href="#val-with_file_iter_records" class="anchor"></a><code><span class="keyword">val</span> with_file_iter_records : Base.string <span>&#45;&gt;</span> <span>f:<span>(<a href="index.html#type-record">record</a> <span>&#45;&gt;</span> Base.unit)</span></span> <span>&#45;&gt;</span> <span>Base.unit Base.Or_error.t</span></code></dt><dd><p><code>with_file_iter_records file_name ~init ~f</code> is like <code>iter_records t ~init ~f</code> except that it is passed a file name, and it manages <code>t</code> automatically. See <a href="index.html#val-with_file"><code>with_file</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-with_file_iteri_records_exn"><a href="#val-with_file_iteri_records_exn" class="anchor"></a><code><span class="keyword">val</span> with_file_iteri_records_exn : Base.string <span>&#45;&gt;</span> <span>f:<span>(Base.int <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> Base.unit)</span></span> <span>&#45;&gt;</span> Base.unit</code></dt><dd><p><code>with_file_iteri_records_exn file_name ~init ~f</code> is like <code>iteri_records_exn t ~init ~f</code> except that it is passed a file name, and it manages <code>t</code> automatically. See <a href="index.html#val-with_file"><code>with_file</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-with_file_iteri_records"><a href="#val-with_file_iteri_records" class="anchor"></a><code><span class="keyword">val</span> with_file_iteri_records : Base.string <span>&#45;&gt;</span> <span>f:<span>(Base.int <span>&#45;&gt;</span> <a href="index.html#type-record">record</a> <span>&#45;&gt;</span> Base.unit)</span></span> <span>&#45;&gt;</span> <span>Base.unit Base.Or_error.t</span></code></dt><dd><p><code>with_file_iteri_records file_name ~init ~f</code> is like <code>iteri_records t ~init ~f</code> except that it is passed a file name, and it manages <code>t</code> automatically. See <a href="index.html#val-with_file"><code>with_file</code></a>.</p></dd></dl></section></section><section><header><h3 id="getting-records-as-a-list"><a href="#getting-records-as-a-list" class="anchor"></a>Getting records as a list</h3><p>These functions return lists of <code>records</code>s.</p></header><dl><dt class="spec value" id="val-records_exn"><a href="#val-records_exn" class="anchor"></a><code><span class="keyword">val</span> records_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-record">record</a> Base.List.t</span></code></dt><dt class="spec value" id="val-records"><a href="#val-records" class="anchor"></a><code><span class="keyword">val</span> records : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-record">record</a> Base.List.t</span> Base.Or_error.t</span></code></dt></dl><section><header><h4 id="with-file-name"><a href="#with-file-name" class="anchor"></a>With file name</h4></header><dl><dt class="spec value" id="val-with_file_records_exn"><a href="#val-with_file_records_exn" class="anchor"></a><code><span class="keyword">val</span> with_file_records_exn : Base.string <span>&#45;&gt;</span> <span><a href="index.html#type-record">record</a> Base.List.t</span></code></dt><dt class="spec value" id="val-with_file_records"><a href="#val-with_file_records" class="anchor"></a><code><span class="keyword">val</span> with_file_records : Base.string <span>&#45;&gt;</span> <span><span><a href="index.html#type-record">record</a> Base.List.t</span> Base.Or_error.t</span></code></dt></dl></section></section><section><header><h3 id="getting-records-as-a-sequence"><a href="#getting-records-as-a-sequence" class="anchor"></a>Getting records as a sequence</h3><p>These are a bit different:</p><p>* There are no <code>with_file</code> versions as you would have to do some fiddly things to keep the channel open, making them not so nice to use.</p><p>* Each <code>record</code> that is yielded is wrapped in an <code>Or_error.t</code>. This is different from the <code>iter</code>, <code>fold</code>, and other non <code>_exn</code> functions in which case the entire result is wrapped in an <code>Or_error.t</code>, letting you ignore errors in the passed in <code>~f</code> function and deal with failure once.</p></header><dl><dt class="spec value" id="val-record_sequence_exn"><a href="#val-record_sequence_exn" class="anchor"></a><code><span class="keyword">val</span> record_sequence_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-record">record</a> Base.Sequence.t</span></code></dt><dd><p><code>record_sequence_exn t</code> returns a <code>Sequence.t</code> of <code>record</code>. May raise exceptions.</p></dd></dl><dl><dt class="spec value" id="val-record_sequence"><a href="#val-record_sequence" class="anchor"></a><code><span class="keyword">val</span> record_sequence : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span><span><a href="index.html#type-record">record</a> Base.Or_error.t</span> Base.Sequence.t</span></code></dt><dd><p><code>record_sequence t</code> is like <code>record_sequence_exn t</code> except that instead of raising exceptions, each item of the sequence is a <code>record Or_error.t</code> rather than an &quot;unwrapped&quot; <code>record</code>. This could make things annoying to deal with. If you don't want exceptions, you could instead wrap your entire sequence processing pipeline in a call to <code>with_file</code> and handle the <code>Or_error.t</code> in that way. See the pipelines usage examples for more info.</p></dd></dl></section></details></div></div></div></div></body></html>