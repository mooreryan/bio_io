<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bio_io__Cigar (bio_io.Bio_io__Cigar)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bio_io</a> &#x00BB; Bio_io__Cigar</nav><h1>Module <code>Bio_io__Cigar</code></h1><p>A module for parsing CIGAR (Concise Idiosyncratic Gapped Alignment Report) strings.</p><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>A CIGAR string is a compressed representation of an aligment.</p><p>Here is an example alignment of two sequences along wth the operations, Match (M), Insertion (I), and Deletion (D).</p><pre><code class="ml">target:     AGTG-TCTTTG
query:      ACTGAACT--G
operation:  MMMMIMMMDDM</code></pre><p>Alignment columns with bases/residues in both the query and the target are considered a <code>Match</code> (even if there are two different bases/residues in the column). Columns with a gap in the target/reference sequence are labeled <code>Insertions</code>, and columns with a gap in the query/read sequence are labeled <code>Deletions</code>.</p><p>The CIGAR string is formed by counting up the runs of operations of the same type. For the above alignment, the operations are <code>MMMMIMMMDDM</code>, so the CIGAR string will be <code>4M1I3M2D1M</code>.</p><h3 id="supported-cigar-operations"><a href="#supported-cigar-operations" class="anchor"></a>Supported CIGAR Operations</h3><ul><li><code>Match</code>: A non-gap alignment position. May be a mismatch.</li><li><code>Insertion</code>: Gap in the target/reference sequence.</li><li><code>Deletion</code>: Gap in the query/read sequence.</li></ul><p>Many programs use CIGAR strings including <a href="http://samtools.github.io/hts-specs/SAMv1.pdf">samtools</a>, <a href="https://drive5.com/usearch/manual/cigar.html">usearch</a>, and <a href="https://github.com/soedinglab/MMseqs2/wiki#alignment-format">MMseqs2</a>. CIGAR strings can vary depending on the program that produces or consumes them, and not all versions are compatible.</p><p>This implementation uses a reduced set of operations used by MMseqs2: Match (M), Insertion (I), and Deletion (D). Eventually, I will implement the rest of the operations, but in the meantime, if your use case requires the full CIGAR spec, please open an <a href="https://github.com/mooreryan/bio_io/issues">issue</a> on GitHub and let me know!</p><h3 id="notes"><a href="#notes" class="anchor"></a>Notes</h3><ul><li>I refer to each number-letter pair as a chunk. Each chunk is a <code>length</code> and an <code>operation</code>. The length specifies the number of consecutive operations.</li><li>Some programs generate chunks without a <code>length</code>--just the <code>operation</code>. In these cases, the length is taken to be 1. So the following CIGAR strings will parse into the same data structure: <code>MIDM</code> and <code>1M1I1D1M</code>.</li><li>Empty CIGAR strings are allowed and do not raise errors.</li></ul><nav class="toc"><ul><li><a href="#api">API</a><ul><li><a href="#length_functions">Length &amp; count functions</a></li><li><a href="#drawing-functions">Drawing Functions</a></li></ul></li></ul></nav></header><section><header><h2 id="api"><a href="#api" class="anchor"></a>API</h2></header><dl><dt class="spec exception" id="exception-Exn"><a href="#exception-Exn" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Exn</span> <span class="keyword">of</span> Base.string</code></dt></dl><div><div class="spec include"><div class="doc"></div></div></div><dl><dt class="spec exception" id="exception-Int_overflow"><a href="#exception-Int_overflow" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Int_overflow</span> <span class="keyword">of</span> Base.int * Base.int</code></dt></dl><div><div class="spec include"><div class="doc"></div></div></div><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt></dl><div><div class="spec include"><div class="doc"><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val</span> equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.bool</code></dt></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> Ppx_sexp_conv_lib.Sexpable.S <span class="keyword">with</span> <span class="keyword">type</span> <a href="index.html">Bio_io__Cigar</a>.t := <a href="index.html#type-t">t</a></code></span></summary><dl><dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span class="keyword">val</span> t_of_sexp : Sexplib0__.Sexp.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Sexplib0__.Sexp.t</code></dt></dl></details></div></div></div></div></div></div><dl><dt class="spec value" id="val-of_string_exn"><a href="#val-of_string_exn" class="anchor"></a><code><span class="keyword">val</span> of_string_exn : Base.string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>of_string_exn string</code> parses string into a cigar <code>t</code>. Raises exceptions on parse error. Valid cigar strings look something like this: <code>1M2I3D5M</code>.</p></dd></dl><dl><dt class="spec value" id="val-of_string"><a href="#val-of_string" class="anchor"></a><code><span class="keyword">val</span> of_string : Base.string <span>&#45;&gt;</span> <span><a href="index.html#type-t">t</a> Base.Or_error.t</span></code></dt><dd><p><code>of_string string</code> parses string into a cigar <code>t Or_error.t</code>. Should not raise exceptions. If <code>of_string</code> raises an exception, then you've found a bug. Valid cigar strings look something like this: <code>1M2I3D5M</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val</span> to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.string</code></dt><dd><p><code>to_string t</code> converts a cigar from the internal representation to a printable string.</p><pre><code class="ml">let s = &quot;1M2I3D5M&quot; in
assert (s = Cigar.to_string @@ Cigar.of_string_exn &quot;1M2I3D5M&quot;)</code></pre><p>Note that not all cigar strings will &quot;round-trip&quot; like the above example. If the input cigar string has no number specifying the length of a chunk, then that chunk is inferred to be of length 1. E.g.,</p><pre><code class="ml">let s = &quot;MDIM&quot; in
assert (&quot;1M1D1I1M&quot; = Cigar.to_string @@ Cigar.of_string_exn &quot;1M2I3D5M&quot;)</code></pre></dd></dl><section><header><h3 id="length_functions"><a href="#length_functions" class="anchor"></a>Length &amp; count functions</h3><p>The following functions return information about the aligment as inferred from the CIGAR string. Each of the examples uses this CIGAR string, <code>1M2I3D5M</code>, which represents the following alignment.</p><pre><code class="ml">target: X--XXXXXXXX
query:  XXX---XXXXX
op:     MIIDDDMMMMM</code></pre><p>Then &quot;length&quot; calculating functions can overflow on CIGAR strings describing genome alignments. In practice, this won't happen often as generally you will be parsing the results of local alignments, e.g., from BLAST, MMseqs2, or reading SAM files.</p><p>Since it is possible to overflow integer arithmetic on CIGAR strings you may parse, the length functions use an addition function that raises <code>Int_overflow</code> exceptions rather than use <a href="https://ocaml.org/api/Int.html">two's complement wrapping</a>.</p><p>Thus, there are two versions, those that end in <code>_exn</code> that may raise <code>Int_overflow</code> and those that return <code>t Or_error.t</code>, which catch <code>Int_overflow</code> and other exceptions.</p></header><dl><dt class="spec value" id="val-alignment_length_exn"><a href="#val-alignment_length_exn" class="anchor"></a><code><span class="keyword">val</span> alignment_length_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.int</code></dt><dt class="spec value" id="val-alignment_length"><a href="#val-alignment_length" class="anchor"></a><code><span class="keyword">val</span> alignment_length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Base.int Base.Or_error.t</span></code></dt><dd><p><code>alignment_length t</code> returns the total length of the aligment as inferred by the Cigar string.</p><p>Here is the alignment for this CIGAR string:</p><pre><code class="ml">assert (11 = Cigar.alignment_length @@ Cigar.of_string_exn &quot;1M2I3D5M&quot;)</code></pre></dd></dl><dl><dt class="spec value" id="val-num_gaps_exn"><a href="#val-num_gaps_exn" class="anchor"></a><code><span class="keyword">val</span> num_gaps_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.int</code></dt><dt class="spec value" id="val-num_gaps"><a href="#val-num_gaps" class="anchor"></a><code><span class="keyword">val</span> num_gaps : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Base.int Base.Or_error.t</span></code></dt><dd><p><code>num_gaps t</code> returns the total number of gap columns in the alignment.</p><pre><code class="ml">assert (5 = Cigar.num_gaps @@ Cigar.of_string_exn &quot;1M2I3D5M&quot;)</code></pre></dd></dl><dl><dt class="spec value" id="val-num_matches_exn"><a href="#val-num_matches_exn" class="anchor"></a><code><span class="keyword">val</span> num_matches_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.int</code></dt><dt class="spec value" id="val-num_matches"><a href="#val-num_matches" class="anchor"></a><code><span class="keyword">val</span> num_matches : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Base.int Base.Or_error.t</span></code></dt><dd><p><code>num_matches t</code> returns the number of matches in the alignment.</p><pre><code class="ml">assert (6 = Cigar.num_matches @@ Cigar.of_string_exn &quot;1M2I3D5M&quot;)</code></pre><p>This is &quot;ungapped alignment length&quot; as in https://doi.org/10.1093/bioinformatics/bty262. Where ungapped is the alignment length minus number of gaps. I'm taking that to mean any position with a gap in either sequence is not counted. So the ungapped_length is the number of matches.</p></dd></dl><dl><dt class="spec value" id="val-query_length_exn"><a href="#val-query_length_exn" class="anchor"></a><code><span class="keyword">val</span> query_length_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.int</code></dt><dt class="spec value" id="val-query_length"><a href="#val-query_length" class="anchor"></a><code><span class="keyword">val</span> query_length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Base.int Base.Or_error.t</span></code></dt><dd><p><code>query_length t</code> returns the length of the query/read within the boundaries of the alignment. This is the length of the query as inferred by the Cigar string. If it is a local aligment, it may not be equal to the length of the entire query sequence.</p><pre><code class="ml">assert (8 = Cigar.query_length @@ Cigar.of_string_exn &quot;1M2I3D5M&quot;)</code></pre></dd></dl><dl><dt class="spec value" id="val-target_length_exn"><a href="#val-target_length_exn" class="anchor"></a><code><span class="keyword">val</span> target_length_exn : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.int</code></dt><dt class="spec value" id="val-target_length"><a href="#val-target_length" class="anchor"></a><code><span class="keyword">val</span> target_length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Base.int Base.Or_error.t</span></code></dt><dd><p><code>target_length t</code> returns the length of the target/reference within the boundaries of the alignment. This is the length of the target as inferred by the Cigar string. If it is a local aligment, it may not be equal to the length of the entire target sequence.</p><pre><code class="ml">assert (9 = Cigar.target_length @@ Cigar.of_string_exn &quot;1M2I3D5M&quot;)</code></pre></dd></dl></section><section><header><h3 id="drawing-functions"><a href="#drawing-functions" class="anchor"></a>Drawing Functions</h3><p>Drawing functions can also raise <code>Int_overflow</code> because they rely on the length functions. Use <code>draw</code> rather than <code>draw_exn</code> to catch errors.</p></header><dl><dt class="spec value" id="val-draw_exn"><a href="#val-draw_exn" class="anchor"></a><code><span class="keyword">val</span> draw_exn : <span>?&#8288;max_aln_len:Base.int</span> <span>&#45;&gt;</span> <span>?&#8288;gap:Base.char</span> <span>&#45;&gt;</span> <span>?&#8288;non_gap:Base.char</span> <span>&#45;&gt;</span> <span>?&#8288;wrap:Base.int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Base.string</code></dt><dt class="spec value" id="val-draw"><a href="#val-draw" class="anchor"></a><code><span class="keyword">val</span> draw : <span>?&#8288;max_aln_len:Base.int</span> <span>&#45;&gt;</span> <span>?&#8288;gap:Base.char</span> <span>&#45;&gt;</span> <span>?&#8288;non_gap:Base.char</span> <span>&#45;&gt;</span> <span>?&#8288;wrap:Base.int</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>Base.string Base.Or_error.t</span></code></dt><dd><p><code>draw t ~max_aln_len ~gap ~non_gap ~wrap</code> outputs a string representation of the aligmnent as inferred from the CIGAR string. This function is mainly just for fun or if you want to learn how CIGAR strings work :)</p><ul><li>Use <code>max_aln_len</code> to prevent &quot;drawing&quot; alignments that are longer than this value. Currently, this function allocates a string approx. three times the entire size of the alignment. So keep this low... :) Default is <code>1000</code>.</li><li><code>gap</code> is the character to use for gaps. Default: <code>'-'</code>.</li><li><code>non_gap</code> is the character to use for non-gaps. Default <code>'X'</code>.</li><li><code>wrap</code> is the max length of the sequence to show in a line before wrapping. Default is <code>60</code>.</li></ul><p>E.g., this <code>print_endline @@ draw &quot;1M2I3D5M&quot;</code></p><p>would print this:</p><pre><code class="ml">target: X--XXXXXXXX
query:  XXX---XXXXX
op:     MIIDDDMMMMM</code></pre><h4 id="wrapping-long-sequences"><a href="#wrapping-long-sequences" class="anchor"></a>Wrapping long sequences</h4><p>You can wrap long sequences so they don't take up so much horizontal space. This code</p><pre><code class="ml">print_endline @@ Cigar.draw ~wrap:10 @@ Cigar.of_string_exn &quot;25M&quot;</code></pre><p>will print out</p><pre><code class="ml">t: XXXXXXXXXX
q: XXXXXXXXXX
o: MMMMMMMMMM

t: XXXXXXXXXX
q: XXXXXXXXXX
o: MMMMMMMMMM

t: XXXXX
q: XXXXX
o: MMMMM</code></pre></dd></dl></section></section></div></body></html>